/*
 * HCSR04.c
 *
 *  Created on: 2019年7月25日
 *      Author: JOJO
 */

#include "HCSR04.h"

static long period[5];									//存放距离数据
static int  avg = 0;
/*
 * 说明:
 *			    _________
 * 			__|	          |____________   ECON信号的高电平代表声波发出到返回的时间
 * 			当高电平的持续时间过长可能超出一个主定时器(该处为TA2CCTL0)的周期 [65535]
 * 			OutTime 作为"尺子" 负责记录溢出次数, 数据处理时将该部分补足.
 *
 * */
static int  OutTime = 0;								//溢出时间的次数
static char avoid_times = 0;

/*
 * PWM波 ;捕获通道  初始化
 * 功能:
 * 			1. PWM波(TA2CCTL1)    [ P2.4输出 ]   为HC-SR04提供触发信号 (高电平20us)
 * 			2. 捕获通道( TA2CCTL2)  [ P2.5输出 ]   捕获从HC-SR04传来的脉冲
 * 				上升沿捕获和下降沿捕获交替进行 (捕获高电平)
 * */
void pwm_catch_init()
{
		 P2OUT &=~BIT5;			//捕获  IO输入
		 P2SEL  |= BIT5;

		 P2DIR |= BIT4;				//PWM IO口输出
		 P2SEL |= BIT4;

		 TA2CTL = 0;
		 TA2CTL  |=  TASSEL_2 + ID_0 + MC_2+ TACLR + TAIE ;				//SMCLK ; 增计数模式
		 TA2CCTL1 |= OUTMOD_7;																//PWM

		 TA2CCR1 = 500;				// 时钟为25M,  500 计数周期为20us

		 TA2CCTL2 |= CCIE + CM_1 +SCS + CAP +CCIS_0;	//捕获通道,初始为上升沿捕获
//		 TA2CCTL2 &=~BIT4;		//禁止捕获通道中断
}

// 距离数据的处理
void Deal_Distance()
{
	char str_dis[8];
	sprintf(str_dis,"%d",avg);
	DrawcharS(str_dis,2,7);
}

/*
 * 捕获事件的处理
 * 功能:
 * 			1. 如果是上升沿捕获,则将主定时器计数值清零,反转为下降沿捕获,等待下一次捕获中断
 * 			2. 如果是下降沿捕获,则取出计数值  [TA2CCR2] , 加上溢出时间,完成一次距离的采集
 * 			3. 对采集到的距离数据进行处理
 * */
void event_Catch()
{
	static int  arr_num =0;
	switch((TA2CCTL2 & CM_2) )		//判断是否为下降沿
			{
				case 0 :								//上升沿
					TA2CCTL2 &=~CM_1;
					TA2CCTL2  |=CM_2;		   			//反转为下降沿触发
					TA2R = 0;						   	//清空计数值
					OutTime = 0;
					break;

				default:								//下降沿
					period[arr_num] = (TA2CCR2 + OutTime*65535)/(25*58);		// 时钟频率25M ,  距离 (cm) = 高电平时长 (us)  /  58
					if(period[arr_num]>400 || period[arr_num]<=0 )						// 如果采集的数据不合理, 舍弃
						{
							arr_num=arr_num-1;
						}
					TA2CCTL2 &=~CM_2;
					TA2CCTL2  |=CM_1;					//反转为上升沿触发
					 OutTime = 0;
					arr_num++;
					break;
			}

	if(arr_num == 5)								//当采集完5次距离数据
	{
		arr_num=0;
		avg = (period[0] + period[1] +period[2] +period[3] +period[4])/5;
	}
	if(avg <=15)
	{
		MODE = AVOID ;
		avoid_times++;
		LED1_HIGH;
	}
	switch(MODE)
	{
		case AVOID:
			Car_Avoid();
			break;
		default:
			break;
	}
}

void Car_Avoid(void)
{
	switch(avoid_times)
	{
		case 1:
				Car_Spinleft(80,500);
				break;
		case 2:
				Car_Spinleft(80,500);
				break;
		default:
				MODE = LIGHT;
				break;
	}
}
/*
 * 捕获到上升或下降沿时触发中断
 * */
#pragma vector=TIMER2_A1_VECTOR
__interrupt void Timer2_A1 (void)
{
//	TA2CCTL1 &=~TAIFG;
	switch(TA2IV)							//对中断源进行判断
	{
		case TA2IV_TACCR2:					//捕获通道2中断
					event_Catch(); break;

		case TA2IV_TAIFG:					//主定时器溢出中断
					OutTime++; break;

		default: break;
	}
}
